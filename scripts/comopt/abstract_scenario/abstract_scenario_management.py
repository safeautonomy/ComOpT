#
#    ComOpT: COMbination and OPtimization for Testing autonomous driving systems
#
#    Copyright (C) 2021  Yuhang Chen, Chih-Hong Cheng, Changwen Li, Tiantian Sun, Rongjie Yan
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published
#    by the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

import os
import numpy as np 
import scipy
import math
import scipy.misc
import xml.etree.ElementTree as ET
from xml.dom import minidom
from ..abstract_scenario import milp

"""
Implementation taken from nn-dependability-kit
"""
class ScenarioKProjectionMetricManager():
    """For the set of inputs with semantic information contained, compute the quantitative k-projection coverage.
    """
    def __init__(self, abstract_scenario_combination_file, k_value = 2):
    

        self.kValue = k_value   
    
        self.sd = MetaScenarioDescription(abstract_scenario_combination_file)

        max_type = [0] * len(self.sd.operating_condition_criteria)

        for i in range(len(max_type)):
            max_type[i] = len(self.sd.operating_condition_items[self.sd.operating_condition_criteria[i]])

            
        self.cm = CoverageManagement(self.kValue, len(max_type), max_type);            

        # Domain restriction
        self.dr = DomainRestrictions()
        
    def add_domain_restrictions_from_file(self, file_name):
        self.dr.add_domain_restrictions_from_file(file_name, self.sd.operating_condition_criteria, self.sd.operating_condition_items)

    
    def add_scenarios_from_file(self, file_name):

        allScenarios = []

        # Read and process input file
        tree = ET.parse(file_name)
        root = tree.getroot()

        for child in root:
               
            if child.tag != "scenario":
                raise Exception("Error in parsing the XML")
                
            scenario = [-1] * len(self.sd.operating_condition_criteria)
            for subchild in child:
                operatingCondition = subchild.tag
                if(operatingCondition == "data_source"):
                    continue
                    
                value = subchild.text.strip()
                scenario[self.sd.operating_condition_criteria.index(operatingCondition)] = self.sd.operating_condition_items[operatingCondition].index(value)            
            allScenarios.append(scenario)
        
        for scenario in allScenarios:
            self.cm.insert_test_case(scenario)
            
        self.cm.printMetricQuantity()
        
    def write_scenario_to_file(self, variable_assignment, output_file):
        top = ET.Element("scenarios")
        comment = ET.Comment("New scenario generated by MILP")
        top.append(comment)
        
        scenario = ET.SubElement(top, "scenario")
        for criterion in self.sd.operating_condition_criteria:
            for assignment in self.sd.operating_condition_items[criterion]: 
                var = milp.create_value_assignment_variable(self.sd.operating_condition_criteria.index(criterion), self.sd.operating_condition_items[criterion].index(assignment))
                if(variable_assignment[var] == 1):
                    child = ET.SubElement(scenario, str(criterion))
                    child.text = str(assignment)
                    # print("for criterion "+str(criterion)+", set it to "+str(assignment))

        new_scenario = ET.tostring(top, "utf-8")
        reparsed = minidom.parseString(new_scenario)
        #print(reparsed.toprettyxml(indent="  "))
        if os.path.dirname(output_file):
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
        secnario_file = open(output_file, "w")
        secnario_file.write(reparsed.toprettyxml(indent="  "))
        secnario_file.close()

    def translate_assignment_to_abstract_scenario(self, variable_assignment):

        scenario = {}

        for criterion in self.sd.operating_condition_criteria:
            for assignment in self.sd.operating_condition_items[criterion]: 
                var = milp.create_value_assignment_variable(self.sd.operating_condition_criteria.index(criterion), self.sd.operating_condition_items[criterion].index(assignment))
                if(variable_assignment[var] == 1):
                    scenario[str(criterion)] = str(assignment)
                    # print("for criterion "+str(criterion)+", set it to "+str(assignment))

        return scenario

class CoverageManagement:
    """For the set of inputs with semantic information contained, compute the quantitative k-projection coverage.
    Attributes:
        kValue: The constant k value for creating the coverage table
        numberOfCategorizations:
        maxType: 
        projectionRecords:
    """
    def __init__(self, k_value, number_of_categorizations, max_type):
        

        if not ((k_value == 1 or k_value == 2) or k_value == 3):
            raise Exception('for k-projection coverage where k > 3, it is not supported')
            
        self.kValue = k_value
        self.number_of_categorizations = number_of_categorizations
        self.maxType = max_type
        self.projection_records = {}

        if (k_value == 1): 
            for i in range(number_of_categorizations):  
                projectionType = [0] * 1
                projectionType[0] = max_type[i]
                self.projection_records[str(i)] = ProjectionRecord(k_value, projectionType)
            

        elif (k_value == 2): 
            for i in range(number_of_categorizations):  
                for j in range(i+1, number_of_categorizations):  
                    projectionType = [0] * 2
                    projectionType[0] = max_type[i]
                    projectionType[1] = max_type[j]
                    self.projection_records[str(i)+"_"+str(j)] = ProjectionRecord(k_value, projectionType)

            
        elif (k_value == 3): 
            for i in range(number_of_categorizations):  
                for j in range(i+1, number_of_categorizations):  
                    for k in range(j+1, number_of_categorizations):  
                        projectionType = [0] * 3
                        projectionType[0] = max_type[i]
                        projectionType[1] = max_type[j]
                        projectionType[2] = max_type[k]
                        self.projection_records[str(i)+"_"+str(j)+"_"+str(k)] = ProjectionRecord(k_value, projectionType)
                    
    
    def printMetricQuantity(self):
    
        
        improvedItem = 0
        totalItems = 0
        for projectedCategorization, projRec in self.projection_records.items():
            #print(projectedCategorization)
            #print("\t"+str(projRec.currentlyOccupiedEntities))
            #print("\t"+str(projRec.maxOccupiedEntities))
            for value, currentQuantity in projRec.currently_occupied_entities.items():
                totalItems = totalItems + projRec.max_occupied_entities[value]
                if (currentQuantity < projRec.max_occupied_entities[value]) :
                    # This item can be improved
                    improvedItem = improvedItem + (projRec.max_occupied_entities[value] - currentQuantity)
        
        
        print(str(self.kValue) + "-projection coverage (without considering domain restrictions): " + str(totalItems - improvedItem) + "/" + str(totalItems))


    def add_domain_restriction_constraints(self):
        print("dummy")
    
    def insert_test_case(self, input_vector):
        
        # print(input_vector)
        # print(self.projection_records)

        if self.number_of_categorizations != len(input_vector):
            return False
            
        if (self.kValue == 1) :
            for i in range(self.number_of_categorizations):  
                self.projection_records[str(i)].currently_occupied_entities[str(input_vector[i])] =  self.projection_records[str(i)].currentlyOccupiedEntities[str(input_vector[i])] + 1 
            return True
        elif (self.kValue == 2): 
            for i in range(self.number_of_categorizations):  
                for j in range(i+1, self.number_of_categorizations):  
                    self.projection_records[str(i)+ "_" + str(j)].currently_occupied_entities[str(input_vector[i])+"_"+str(input_vector[j])] =  (
                        self.projection_records[str(i)+ "_" + str(j)].currently_occupied_entities[str(input_vector[i])+"_"+str(input_vector[j])]  + 1)
            return True
        elif (self.kValue == 3): 
            for i in range(self.number_of_categorizations):  
                for j in range(i+1, self.number_of_categorizations):  
                    for k in range(j+1, self.number_of_categorizations):  
                        self.projection_records[str(i)+ "_" + str(j)+"_" + str(k)].currently_occupied_entities[str(input_vector[i])+"_"+str(input_vector[j])+"_"+str(input_vector[k])] = (
                            self.projection_records[str(i)+ "_" + str(j)+"_" + str(k)].currently_occupied_entities[str(input_vector[i])+"_"+str(input_vector[j])+"_"+str(input_vector[k])]  + 1 )
            return True
        else: 
            return False
        

    def dump_metric_state(self):
        print(self.projection_records)

    
        
class ProjectionRecord():
    """Single table belonging to a particular projection.
    Attributes:
        kValue: The constant k value for creating the coverage table
    """

    def __init__(self, k_value, max_type):
            
        if not ((k_value == 1 or k_value == 2) or k_value == 3):
            raise Exception('for k-projection coverage where k > 3, it is not supported')
            
        self.kValue = k_value    
        self.currently_occupied_entities = {}
        self.max_occupied_entities = {}
        
        if self.kValue == 1: 
            for i in range(max_type[0]):
                self.currently_occupied_entities[str(i)] = 0
                # FIXME: Change below value from 1 to others when quantitative projection is required.
                self.max_occupied_entities[str(i)] = 1

            

        elif self.kValue == 2: 
            for i in range(max_type[0]):
                for j in range(max_type[1]):
                    self.currently_occupied_entities[str(i)+"_"+str(j)] = 0
                    # FIXME: Change below value from 1 to others when quantitative projection is required.
                    self.max_occupied_entities[str(i)+"_"+str(j)] = 1
                
            
        elif self.kValue == 3:
            for i in range(max_type[0]):
                for j in range(max_type[1]):
                    for k in range(max_type[2]):
                        self.currently_occupied_entities[str(i)+"_"+str(j)+"_"+str(k)] = 0
                        # FIXME: Change below value from 1 to others when quantitative projection is required.
                        self.max_occupied_entities[str(i)+"_"+str(j)+"_"+str(k)] = 1
        else:
            raise Exception("Currently k>3 is not supported")

            
class MetaScenarioDescription():       

    def __init__(self, file_name):
        self.operating_condition_criteria = [];
        self.operating_condition_items = {};

        # Read and process input file
        tree = ET.parse(file_name)
        root = tree.getroot()

        for child in root:
            nodeName = child.tag
            options = [x.strip() for x in child.text.split(',')]
            self.operating_condition_items[nodeName] = options
            self.operating_condition_criteria.append(nodeName);
       
        for key, value in self.operating_condition_items.items():
            if len(value) >= 10:
                raise Exception("Currently the system is not able to process a condition with more than 10 elements due to internal string processing")
       
    def printScenarioDescription(self):
        print(str(self.operating_condition_criteria))
        print(str(self.operating_condition_items))
    
    
class DomainRestrictions():    

    def __init__(self):
        self.domainRestrictions = []
 
    def add_domain_restrictions_from_file(self, file_name, operating_condition_criteria, operating_condition_items):
 

        # Read and process input file
        tree = ET.parse(file_name)
        root = tree.getroot()
        
        for child in root:
               
            if child.tag != "constraint":
                raise Exception("Error in parsing the XML")
                
            ex = milp.Expression()    
            
            for subchild in child:
                tag = subchild.tag
                value = subchild.text.strip()
                if tag == "upperbound":
                    if value == "MAX":
                        ex.upperbound = math.inf
                    elif value == "MIN":
                        ex.upperbound = -math.inf
                    else:
                        ex.upperbound = float(value)
                elif tag == "lowerbound":
                    if value == "MAX":
                        ex.lowerbound = math.inf
                    elif value == "MIN":
                        ex.lowerbound = -math.inf
                    else:
                        ex.lowerbound = float(value)
                elif tag == "item":
                    options = [x.strip() for x in value.split(',')]
                    coefficient = float(options[0])
                    criteria = options[1].split('.')[0]
                    value = options[1].split('.')[1]
                    ex.variables.append(milp.create_value_assignment_variable(operating_condition_criteria.index(criteria), operating_condition_items[criteria].index(value)))
                    ex.coefficients.append(coefficient)
                    
                else:
                    raise Exception("Error in parsing the XML")

            ex.print_expression()
            self.domainRestrictions.append(ex)       
   
